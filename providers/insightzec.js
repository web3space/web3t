// Generated by LiveScript 1.6.0
(function(){
  var moment, ref$, map, foldl, any, each, find, sum, filter, get, post, plus, minus, div, times, BitcoinLib, jsonParse, deadline, calcFee, getKeys, extend, getDec, addValue, getOutputs, createTransaction, pushTx, getBalance, transformTx, getTransactions, out$ = typeof exports != 'undefined' && exports || this, toString$ = {}.toString;
  moment = require('moment');
  ref$ = require('prelude-ls'), map = ref$.map, foldl = ref$.foldl, any = ref$.any, each = ref$.each, find = ref$.find, sum = ref$.sum, filter = ref$.filter;
  ref$ = require('superagent'), get = ref$.get, post = ref$.post;
  ref$ = require('../math.js'), plus = ref$.plus, minus = ref$.minus, div = ref$.div, times = ref$.times;
  BitcoinLib = require('bitcoinjs-lib-zcash');
  jsonParse = require('../json-parse.js');
  deadline = require('../deadline.js');
  out$.calcFee = calcFee = function(arg$, cb){
    var network, tx;
    network = arg$.network, tx = arg$.tx;
  };
  out$.getKeys = getKeys = function(arg$, cb){
    var network, mnemonic, index;
    network = arg$.network, mnemonic = arg$.mnemonic, index = arg$.index;
  };
  extend = curry$(function(add, json){
    return import$(json, add);
  });
  getDec = function(network){
    var decimals;
    decimals = network.decimals;
    return Math.pow(10, decimals);
  };
  addValue = curry$(function(network, it){
    var dec;
    dec = getDec(network);
    return it.value = (function(){
      switch (false) {
      case it.satoshis == null:
        return it.satoshis;
      case it.amount == null:
        return times(it.amount, dec);
      default:
        return 0;
      }
    }());
  });
  getOutputs = curry$(function(arg$, cb){
    var network, address, url;
    network = arg$.network, address = arg$.address;
    url = network.api.url;
    return get(url + "/api/addr/" + address + "/utxo").then(function(body){
      return jsonParse(body.text, function(err, result){
        if (err != null) {
          return cb(err);
        }
        if (toString$.call(result).slice(8, -1) !== 'Array') {
          return cb("Result is not an array");
        }
        return function(it){
          return cb(null, it);
        }(
        map(extend({
          network: network,
          address: address
        }))(
        each(addValue(network))(
        result)));
      });
    });
  });
  out$.createTransaction = createTransaction = function(arg$, cb){
    var network, account, recipient, amount, amountFee;
    network = arg$.network, account = arg$.account, recipient = arg$.recipient, amount = arg$.amount, amountFee = arg$.amountFee;
    return getOutputs({
      network: network,
      address: account.address
    }, function(err, outputs){
      var isNoValue, dec, value, fee, total, tx, rest, apply, sign, rawtx;
      if (err != null) {
        return cb(err);
      }
      if (outputs.length === 0) {
        return cb('Not Enough Funds (Unspent Outputs)');
      }
      isNoValue = find(function(it){
        return it.value == null;
      })(
      outputs);
      if (isNoValue) {
        return cb('Each output should have a value');
      }
      dec = getDec(network);
      value = times(amount, dec);
      fee = times(amountFee, dec);
      total = sum(
      map(function(it){
        return it.value;
      })(
      outputs));
      if (isNaN(total)) {
        return cb('Total is NaN');
      }
      tx = new BitcoinLib.TransactionBuilder(network);
      rest = minus(minus(total, value), fee);
      tx.addOutput(recipient, +value);
      tx.addOutput(account.address, +rest);
      apply = function(output, i){
        return tx.addInput(output.txid, output.vout);
      };
      sign = function(output, i){
        var key;
        key = BitcoinLib.ECPair.fromWIF(account.privateKey, network);
        return tx.sign(i, key);
      };
      outputs.forEach(apply);
      outputs.forEach(sign);
      rawtx = tx.build().toHex();
      return cb(null, {
        rawtx: rawtx
      });
    });
  };
  out$.pushTx = pushTx = curry$(function(arg$, cb){
    var network, rawtx, url;
    network = arg$.network, rawtx = arg$.rawtx;
    url = network.api.url;
    return post(url + "/api/tx/send", {
      rawtx: rawtx
    }).then(function(res){
      if (res.badRequest) {
        return cb(res.body);
      }
      return cb(null, res.body);
    });
  });
  out$.getBalance = getBalance = function(arg$, cb){
    var address, network, ref$;
    address = arg$.address, network = arg$.network;
    if ((network != null ? (ref$ = network.api) != null ? ref$.url : void 8 : void 8) == null) {
      return cb("Url is not defined");
    }
    return get(network.api.url + "/api/addr/" + address + "/balance").end(function(err, data){
      var dec, num;
      if (err != null || data.text.length === 0) {
        return cb(err);
      }
      dec = getDec(network);
      num = div(data.text, dec);
      cb(null, num);
    });
  };
  transformTx = curry$(function(net, t){
    var sameValue, network, tx, time, amount, fee, ref$, to, ref1$, ref2$, url;
    sameValue = function(out){
      return parseFloat(minus(out.value, t.valueOut)) === 0;
    };
    network = net.token;
    tx = t.txid;
    time = t.time;
    amount = t.valueOut;
    fee = (ref$ = t.fees) != null ? ref$ : 0;
    to = (ref$ = t.vout) != null ? typeof ref$.filter == 'function' ? (ref1$ = ref$.filter(sameValue)) != null ? (ref2$ = ref1$.map(function(it){
      var ref$, ref1$;
      return (ref$ = it.scriptPubKey) != null ? (ref1$ = ref$.addresses) != null ? ref1$[0] : void 8 : void 8;
    })) != null ? ref2$[0] : void 8 : void 8 : void 8 : void 8;
    url = net.api.url + "/tx/" + tx;
    return {
      network: network,
      tx: tx,
      amount: amount,
      fee: fee,
      time: time,
      url: url,
      to: to
    };
  });
  out$.getTransactions = getTransactions = function(arg$, cb){
    var network, address, ref$;
    network = arg$.network, address = arg$.address;
    if ((network != null ? (ref$ = network.api) != null ? ref$.url : void 8 : void 8) == null) {
      return cb("Url is not defined");
    }
    return get(network.api.url + "/api/txs/?address=" + address).end(function(err, data){
      if (err != null) {
        return cb(err);
      }
      jsonParse(data.text, function(err, result){
        var txs;
        if (err != null) {
          return cb(err);
        }
        if (toString$.call(result != null ? result.txs : void 8).slice(8, -1) !== 'Array') {
          return cb("Unexpected result");
        }
        txs = map(transformTx(network))(
        result.txs);
        return cb(null, txs);
      });
    });
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
